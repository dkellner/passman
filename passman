#!/bin/bash

# Copyright 2014 Markus Lux

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

SCRIPT_DIR="$( cd "$( dirname "$(readlink -f ${BASH_SOURCE[0]})" )" && pwd -P )"

if [[ -f "$SCRIPT_DIR/config" ]]; then
	. "$SCRIPT_DIR/config"
else
	echo "In order to use passman, you need to set configuration options in the file $SCRIPT_DIR/config"
	exit 1
fi

if [[ ! -f "$PASS_FILE" ]]; then
	echo "Password file $PASS_FILE not found!"
	exit 1
fi

if [[ -z "$PASS_LENGTH" ]]; then
	PASS_LENGTH='15'
fi

# Returns all keys present in the password file.
function getkeys
{
    gpg --no-tty --quiet -q -d "$PASS_FILE" | awk -F'\t' '{print $1}' | sort
}

# Returns all keys and additionally auto-type hints if present
function getkeyshints
{
    gpg --no-tty --quiet -q -d "$PASS_FILE" | awk -F'\t' '{print $1, $4}' OFS='\t' | sort
}

# Gets a login as a string "user<TAB>pass".
function get
{
    if [[ -n "$1" ]]; then
        gpg --no-tty --quiet -q -d "$PASS_FILE" | grep -P "^$1\t" | awk -F'\t' '{print $2, $3}' OFS='\t'
    fi
}

# Gets the hint for a login.
function gethint
{
    if [[ -n "$1" ]]; then
        gpg --no-tty --quiet -q -d "$PASS_FILE" | grep -P "^$1\t" | awk -F'\t' '{print $4}'
    fi
}

# Adds an entry to the password file.
function add
{

	IFS= read -r -p "Identifier: " site
	site=$(echo "$site" | sed -e 's/^ *//g' -e 's/ *$//g') #remove leading/trailing whitespaces
	if [[ -z "$site" ]]; then
		echo "Please specify a site identifier."
		exit 1
	fi

	IFS= read -p "Username (optional): " user
	IFS= read -r -s -p "Password (will not be echoed): " pass
	echo

	echo -e "$site$user$pass" | grep -P '\t' > /dev/null
	if [[ $? -eq 0 ]]; then
		echo "All values must NOT contain any <TAB> characters."
		exit 1
	fi

    if [[ -z "$pass" ]]; then
        pass=$(pwgen -s1 "$PASS_LENGTH")
        echo "Generated password for $user: $pass"
    fi

    line="$site\\t$user\\t$pass"

    passes=$(gpg --no-tty --quiet -d "$PASS_FILE")

    if [[ $? -eq 0 ]]; then
        passes+='\n'
        passes+="$line"
        echo -e "$passes" | gpg $GPG_OPTS --output "$PASS_FILE"
    fi
}

# Deletes an entry from the password file
function del
{
    if [[ -n "$1" ]]; then
        passes=$(gpg --no-tty --quiet -d "$PASS_FILE" | sed "/^$1	/d")

        if [[ $? -eq 0 ]]; then
            echo -e "$passes" | gpg $GPG_OPTS --output "$PASS_FILE"
        fi
    fi
}

# Set auto type hint for specific entry
# First argument: entry key
# Second argument: hint to set
function sethint
{
    if [[ -n "$1" ]]; then
        login=$(get "$1")

        if [[ -z "$login" ]]; then
            echo "Key '$1' not found."
            return
        fi

        if [[ -z "$2" ]]; then
            echo "No regex specified."
            return
        fi

        user=${login%	*}
        password=${login#*	}

        regex=$(echo "$2" | tr -d '\t')
        line="$1\\t$user\\t$password\\t$regex"

        passes=$(gpg --no-tty --quiet -d "$PASS_FILE" | sed "/^$1	/d")

        if [[ $? -eq 0 ]]; then
            passes+='\n'
            passes+="$line"
            echo -e "$passes" | gpg $GPG_OPTS --output "$PASS_FILE"
        fi
    fi
}

# Types the credentials as user<TAB>password<enter>.
# First argument : user
# Second argument: password
function autotype
{
    if [[ -n "$1" ]]; then
        xdotool type -- "$1"
        xdotool key Tab
    fi
    xdotool type -- "$2"
    xdotool key Return
}

# Fills credentials by selecting the desired site with dmenu in a (e.g. browser) form
# First argument : site to submit (optional)
# If first argument is empty, dmenu will pop up
function submitform
{
    if [[ -n "$1" ]]; then
        key="$1"
    else
        keys=$(getkeys)
        key=$(echo "$keys" | dmenu -p "Select:")
    fi

    login=$(get "$key")

    if [[ -z "$login" ]]; then
        return
    fi

    user=${login%	*}
    password=${login#*	}

    autotype "$user" "$password"
}

# Try to match site key against current window name
# If one key matches, the credentials will auto-type automatically
# If more than one key matches, dmenu pops up to choose between them
# If no key matches, standard dmenu will pop up
function autosubmitform
{
    windowname=$(xdotool getwindowfocus getwindowname)

    keyshints=$(getkeyshints)

    matches=()
    OLDIFS="$IFS"; IFS=$'\n'
    for keyhint in $keyshints; do
        key=${keyhint%	*}
        hint=${keyhint#*	}

        if [[ -z "$hint" ]]; then
            hint="$key"
        fi

        echo "$windowname" | grep -Ei "$hint" > /dev/null
        if [[ $? -eq 0 ]]; then
            matches+=( "$key" )
        fi
    done 
    IFS="$OLDIFS"

    numMatches=${#matches[@]};

    case $numMatches in
        0)
            submitform
            ;;
        1)
            submitform "${matches[0]}"
            ;;
        *)
            # trick the IFS to output array items as separate lines for dmenu
            OLDIFS="$IFS"; IFS=$'\n'
            key=$(echo "${matches[*]}" | dmenu -p "Select:")
            IFS="$OLDIFS"
            if [[ -z "$key" ]]; then 
                return; 
            fi
            submitform "$key"
            ;;
    esac
}



# Set up GPG identity. Use symmetric cipher if $GPG_IDENTITY has not been set.
if [[ -z "$GPG_IDENTITY" ]]; then
    GPG_OPTS='--yes --symmetric --cipher-algo AES256'
else
    GPG_OPTS="--yes --encrypt --recipient $GPG_IDENTITY"
fi

# This has to be done to allow empty parameters (e.g. for user-less logins).
params=''
for i in "$@"
do
    params="$params '$i'"
done

# The script parameters determine which method gets called.
eval "$params"
